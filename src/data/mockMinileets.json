[
  {
    "title": "Invert Binary Tree",
    "type": "drag-and-swap",
    "difficulty": "easy",
    "tags": ["binary tree", "recursion"],
    "description": "226. Invert Binary Tree (easy)\nGiven the root of a binary tree, invert the tree, and return its root.\n\nExample 1:\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n\nExample 2:\nInput: root = [2,1,3]\nOutput: [2,3,1]\n\nExample 3:\nInput: root = []\nOutput: []\n\nConstraints:\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100",
    "code": [
      "def invertTree(node):",
      "    if node is None:",
      "    temp = node.left",
      "    node.right = temp",
      "    node.left = node.right",
      "    invertTree(node.left)",
      "    invertTree(node.right)",
      "    return node",
      "        return None"
    ],
    "solution": [1, 2, 9, 3, 5, 4, 6, 7, 8],
    "hint": [
      "Take a closer look at the return statements!",
      "Is the swapping order correct?"
    ]
  },
  {
    "title": "Two Sum",
    "type": "drag-and-swap",
    "difficulty": "easy",
    "tags": ["array", "hash table"],
    "description": "1. Two Sum (easy)\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nConstraints:\n2 <= nums.length <= 10^4\n-10^9 <= nums[i] <= 10^9\n-10^9 <= target <= 10^9",
    "code": [
      "def twoSum(nums, target):", 
      "    return []", 
      "    for i in range(len(nums)):", 
      "        for j in range(i + 1, len(nums)):", 
      "                return [i, j]", 
      "            if nums[i] + nums[j] == target:" 
    ],
    "solution": [1, 3, 4, 6, 5, 2],
    "hint": [
	"Try again!"
    ]
  },
  {
    "title": "Valid Parentheses",
    "type": "drag-and-swap",
    "difficulty": "easy",
    "tags": ["string", "stack"],
    "description": "20. Valid Parentheses (easy)\nGiven a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nExample 1:\nInput: s = \"()\"\nOutput: true\n\nExample 2:\nInput: s = \"()[]{}\"\nOutput: true\n\nExample 3:\nInput: s = \"(]\"\nOutput: false",
    "code": [
      "def isValid(s):", 
      "    stack, mapping = [], {')': '(','}': '{', ']': '['}", 
      "            if not stackor stack.pop() != mapping[char]:", 
      "    for char in s:", 
      "        if char in mapping:", 
      "        else:", 
      "            stack.append(char)", 
      "                return False", 
      "    return not stack"
    ],
    "solution": [1, 2, 4, 5, 3, 8, 6, 7, 9],
    "hint": [
      "Check the order of the return statement!",
      "The stack operations look correct."
    ]
  },
  {
    "title": "Maximum Depth of Binary Tree",
    "type": "drag-and-swap",

    "difficulty": "easy",
    "tags": ["binary tree", "recursion"],
    "description": "104. Maximum Depth of Binary Tree (easy)\nGiven the root of a binary tree, return its maximum depth.\n\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n\nExample 2:\nInput: root = [1,null,2]\nOutput: 2",
    "code": [
      "def maxDepth(root):", 
      "    left_depth, right_depth = maxDepth(root.left), maxDepth(root.right)", 
      "    return max(left_depth, right_depth) + 1", 
      "        return 0", 
      "    if root is None:" 
    ],
    "solution": [1, 5, 4, 2, 3],
    "hint": [
      "The recursive calls should come before the return!",
      "Think about the order of operations."
    ]
  },
  {
    "title": "Merge Two Sorted Lists",
    "type": "drag-and-swap",
    "difficulty": "easy",
    "tags": ["linked list", "recursion"],
    "description": "21. Merge Two Sorted Lists (easy)\nYou are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists in a sorted manner and return the head of the merged linked list.\n\nExample 1:\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\nExample 2:\nInput: list1 = [], list2 = []\nOutput: []",
    "code": [
      "def mergeTwoLists(list1, list2):",
      "    if not list1:",
      "        return list2",
      "    if not list2:",
      "        return list1",
      "    if list1.val <= list2.val:",
      "        list1.next = mergeTwoLists(list1.next, list2)",
      "        return list1",
      "    else:",
      "        list2.next = mergeTwoLists(list1, list2.next)",
      "        return list2"
    ],
    "solution": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
    "hint": [
      "Check the recursive call placement!",
      "The base cases look correct."
    ]
  }
]
